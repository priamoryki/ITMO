# «Парадигмы программирования»

[Условия домашних заданий](http://www.kgeorgiy.info/courses/paradigms/homeworks.html)

[Тесты к домашним заданиям](https://www.kgeorgiy.info/git/geo/paradigms-2021)

## Exam. Интерпретатор Spoon (JavaScript)

Напишите интерпретатор языка программирования [Spoon](https://ru.wikipedia.org/wiki/Spoon)
 * Создайте функцию `runProgram(program, input)` выполняющую программу на языке Spoon.
 * Ввод символов должен осуществляться из строки `input`, а вывод — на консоль.
 * Должна быть возможность ограничить число действий, выполняемых программой и потребляемую память (если превышено — выводить сообщение об ошибке).

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/exam)

## Домашнее задание 1. Бинарный поиск

1.  Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2.  На вход подается целое число `x` и массив целых чисел `a`, отсортированный по невозрастанию. Требуется найти минимальное значение индекса `i`, при котором `a[i] <= x`.
3.  Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4.  Интерфейс программы.
    *   Имя основного класса — `BinarySearch`.
    *   Первый аргумент командной строки — число `x`.
    *   Последующие аргументы командной строки — элементы массива `a`.
5.  Пример запуска: `java BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: `2`.

Модификация:
 * *Span*
    * Требуется вывести два числа: начало и длину диапазона элементов,
      равных `x`. Если таких элементов нет, то следует вывести
      пустой диапазон, у которого левая граница совпадает с местом
      вставки элемента `x`.
    * Не допускается использование типов `long` и `BigInteger`.
    * Класс должен иметь имя `BinarySearchSpan`

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-1)


## Домашнее задание 2. Очередь на массиве

1.  Определите модель и найдите инвариант структуры данных «[очередь](http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит `null`.
2.  Реализуйте классы, представляющие циклическую очередь с применением массива.
    *   Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
    *   Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
    *   Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
    *   Должны быть реализованы следующие функции (процедуры) / методы:
        *   `enqueue` – добавить элемент в очередь;
        *   `element` – первый элемент в очереди;
        *   `dequeue` – удалить и вернуть первый элемент в очереди;
        *   `size` – текущий размер очереди;
        *   `isEmpty` – является ли очередь пустой;
        *   `clear` – удалить все элементы из очереди.
    *   Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
    *   Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3.  Напишите тесты к реализованным классам.

Модификация:
 * *Deque*
    * Реализовать методы
        * `push` – добавить элемент в начало очереди
        * `peek` – вернуть последний элемент в очереди
        * `remove` – вернуть и удалить последний элемент из очереди

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-2)

## Домашнее задание 3. Очередь на связном списке

1.  Определите интерфейс очереди `Queue` и опишите его контракт.
2.  Реализуйте класс `LinkedQueue` — очередь на связном списке.
3.  Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс `AbstractQueue`.

Это домашнее задание _связанно_ с предыдущим.

Модификация:
 * *Contains*
    * Добавить в интерфейс очереди и реализовать методы
        * `contains(element)` – проверяет, содержится ли элемент в очереди
        * `removeFirstOccurrence(element)` – удаляет первое вхождение элемента в очередь 
            и возвращает было ли такое
    * Дублирования кода быть не должно

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-3)

## Домашнее задание 4. Вычисление в различных типах

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

1.  Создайте класс `expression.generic.GenericTabulator`, реализующий интерфейс `expression.generic.Tabulator`:

    <pre>public interface Tabulator {
        Object[][][] tabulate(String mode, String expression, int x1, int x2, int y1, int y2, int z1, int z2) throws Exception;
    }</pre>

    Аргументы

    *   `mode` — режим работы

        <table>

        <tbody>

        <tr>

        <th>Режим</th>

        <th>Тип</th>

        </tr>

        <tr>

        <td>i</td>

        <td>int (с детекцией переполнений)</td>

        </tr>

        <tr>

        <td>d</td>

        <td>double</td>

        </tr>

        <tr>

        <td>bi</td>

        <td><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html">BigInteger</a></td>

        </tr>

        </tbody>

        </table>

    *   `expression` — вычисляемое выражение;
    *   `x1`, `x2`; `y1`, `y2`; `z1`, `z2` — диапазоны изменения переменны (включительно).

    Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.

2.  Доработайте интерфейс командной строки:
    *   Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:

        <table>

        <tbody>

        <tr>

        <th>Опция</th>

        <th>Тип</th>

        </tr>

        <tr>

        <td>-i</td>

        <td>int (с детекцией переполнений)</td>

        </tr>

        <tr>

        <td>-d</td>

        <td>double</td>

        </tr>

        <tr>

        <td>-b</td>

        <td><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html">BigInteger</a></td>

        </tr>

        </tbody>

        </table>

    *   Вторым аргументом командной строки программа должна принимать выражение для вычисления.
    *   Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
3.  Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.9).
4.  Реализация не должна использовать аннотацию [@SuppressWarnings](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6.4.5).
5.  При выполнении задания следует обратить внимание на простоту добавления новых типов и операциий.

Модификация:
 * *AsmUls*
    * Реализовать режимы из модификации *Uls*.
    * Дополнительно реализовать унарные операции:
        * `abs` – модуль числа, `abs -5` равно 5;
        * `square` – возведение в квадрат, `square 5` равно 25.
    * Дополнительно реализовать бинарную операцию (максимальный приоритет):
        * `mod` – взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-4)

## Домашнее задание 5. Функциональные выражения на JavaScript

1.  Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.
2.  Функции должны позволять производить вычисления вида:

    <pre>let expr = subtract(
        multiply(
            cnst(2),
            variable("x")
        ),
        cnst(3)
    );

    println(expr(5));</pre>

    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
3.  Тестовая программа должна вычислять выражение x<sup>2</sup>−2x+1, для `x` от 0 до 10.
4.  **Сложный вариант.** Требуется дополнительно написать функцию `parse`, осуществляющую разбор выражений, записанных в [обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, результатом

    <pre>parse("x x 2 - * x * 1 +")(5)</pre>

    должно быть число `76`.
5.  При выполнение задания следует обратить внимание на:
    *   Применение функций высшего порядка.
    *   Выделение общего кода для операций.

Модификация:
 * *OneMinMax*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `one` – 1;
        * `two` – 2;
    * операций:
        * `min5` – минимальный из пяти аргументов, `3 1 4 0 2 min5` равно 0;
        * `max3` – максимальный из трех аргументов, `3 1 4 max3` равно 4.

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-5)

## Домашнее задание 6. Объектные выражения на JavaScript

1.  Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с одной переменной.
    1.  Пример описания выражения `2x-3`:

        <pre>let expr = new Subtract(
            new Multiply(
                new Const(2),
                new Variable("x")
            ),
            new Const(3)
        );

        println(expr.evaluate(5));</pre>

    2.  При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
    3.  Метод `toString()` должен выдавать запись выражения в [обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, `expr.toString()` должен выдавать «`2 x * 3 -`».
2.  **Сложный вариант.**

    <div>Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и

    <pre>new Subtract(
        new Add(
            new Multiply(new Const(0), new Variable("x")),
            new Multiply(new Const(2), new Const(1))
        )
        new Const(0)
    )</pre>

    так же будут считаться правильным ответом).</div>

    Функция `parse` должна выдавать разобранное объектное выражение.

3.  **Бонусный вариант.** Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,

    <pre>parse("x x 2 - * 1 *").diff("x").simplify().toString()</pre>

    должно возвращать «`x x 2 - +`».
4.  При выполнение задания следует обратить внимание на:
    *   Применение инкапсуляции.
    *   Выделение общего кода для операций.
    *   Минимизацию необходимой памяти.

Модификация:
 * *Cube*. Дополнительно реализовать поддержку:
    * унарных функций:
        * `Cube` (`cube`) – возведение в куб, `3 cube` равно 27;
        * `Cbrt` (`cbrt`) – извлечение кубического корня, `-27 cbrt` равно −3;

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-6)

## Домашнее задание 9. Функциональные выражения на Clojure

1.  Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.
    1.  Пример описания выражения `2x-3`:

        <pre>(def expr
          (subtract
            (multiply
              (constant 2)
              (variable "x"))
            (constant 3)))</pre>

    2.  Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, `(expr {"x" 2})` должно быть равно 1.
2.  Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,

    <pre>(parseFunction "(- (* 2 x) 3)")</pre>

    должно быть эквивалентно `expr`.
3.  **Сложный вариант.** Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
4.  При выполнение задания следует обратить внимание на:
    *   Выделение общего кода для операций.

Модификация:
 * *SumAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `sum` – сумма, `(sum 1 2 3)` равно 6;
        * `avg` – среднее, `(avg 1 2 3)` равно 2;

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-9)

## Домашнее задание 10. Объектные выражения на Clojure

1.  Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.
    1.  Пример описания выражения `2x-3`:

        <pre>(def expr
          (Subtract
            (Multiply
              (Constant 2)
              (Variable "x"))
            (Constant 3)))</pre>

    2.  Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1.
    3.  Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
    4.  Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,

        <pre>(parseObject "(- (* 2 x) 3)")</pre>

        должно быть эквивалентно `expr`.
    5.  Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Constant 2) (Constant 0))` и

        <pre>(Subtract
          (Add
            (Multiply (Constant 0) (Variable "x"))
            (Multiply (Constant 2) (Constant 1)))
          (Constant 0))</pre>

        так же будут считаться правильным ответом.
2.  **Сложный вариант.** Констуркторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
3.  При выполнение задания можно использовать любой способ преставления объектов.

Модификация:
 * *SumAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sum` (`sum`) – сумма, `(sum 1 2 3)` равно 6;
        * `Avg` (`avg`) – арифметическое среднее, `(avg 1 2 3)` равно 2;

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-10)

## Домашнее задание 12. Простые числа на Prolog

1.  Разработайте правила:

    *   `prime(N)`, проверяющее, что `N` – простое число.
    *   `composite(N)`, проверяющее, что `N` – составное число.
    *   `prime_divisors(N, Divisors)`, проверяющее, что список `Divisors` содержит все простые делители числа `N`, упорядоченные по возрастанию. Если `N` делится на простое число `P` несколько раз, то `Divisors` должен содержать соответствующее число копий `P`.
2.  Варианты

    *   Простой: `N` ≤ 1000.
    *   Сложный: `N` ≤ 10<sup>5</sup>.
    *   Бонусный: `N` ≤ 10<sup>7</sup>.
3.  Вы можете рассчитывать, на то, что до первого запроса будет выполнено правило `init(MAX_N)`.

Модификация:
 * *Gcd*
    * Добавьте правило `gcd(A, B, GCD)`,
      подсчитывающее НОД(`A`, `B`) через разложение на простые множители:  
      `gcd(4, 6, 2)`.

[Реализация](https://github.com/priamoryki/ITMO/tree/main/semester-2/paradigms/HW-12)
